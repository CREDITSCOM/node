
#include <gtest/gtest.h>
#include "datastream.h"

TEST(DataStream, DataPointerIsCorrectAfterCreation) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_EQ(stream.data(), data);
}

TEST(DataStream, SizeIsCorrect) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_EQ(stream.size(), sizeof data);
}

TEST(DataStream, IsValidAfterCreation) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_TRUE(stream.isValid());
}

TEST(DataStream, IsAvailableReturnsTrueIfRequestedEnough) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_TRUE(stream.isAvailable(8));
}

TEST(DataStream, IsAvailableReturnsTrueIfRequestedZero) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_TRUE(stream.isAvailable(0));
}

TEST(DataStream, IsAvailableReturnsFalseIfRequestedTooMany) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_FALSE(stream.isAvailable(9));
}

TEST(DataStream, MustGetCorrectStdArrayFromStream) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  auto result_array = stream.streamArray<sizeof data>();
  ASSERT_EQ(result_array[7], '\0');
  ASSERT_EQ(8, result_array.size());
  std::array<char, 8> test_array = {'1', '2', '3', '4', '5', '6', '7', '\0'};
  ASSERT_EQ(test_array, result_array);
}

TEST(DataStream, MustGetZeroFilledStdArrayIfRequestedMoreThanAvailable) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  auto result_array = stream.streamArray<10>();
  ASSERT_EQ(result_array.size(), 10);
  for (auto i = 0u; i < result_array.size(); ++i) {
    ASSERT_EQ(result_array[i], 0);
  }
}

TEST(DataStream, EndPointWithIp4AndPortIsCorrectlyWritrenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  boost::asio::ip::udp::endpoint endpoint(
      boost::asio::ip::address::from_string("127.0.0.1"), 80);
  stream.addEndpoint(endpoint);
  const char encoded[7] = {0x06, 0x7f, 0x00, 0x00, 0x01, 0x50, 0x00};
  ASSERT_EQ(stream.size(), 7);
  ASSERT_TRUE(0 == memcmp(encoded, stream.data(), sizeof encoded));
}

TEST(DataStream, EndPointWithIp4AndPortIsCorrectlyReadFromStream) {
  char data[] = {0x06, 0x7f, 0x00, 0x00, 0x01, 0x50, 0x00};
  cs::DataStream stream(data, sizeof data);
  boost::asio::ip::udp::endpoint endpoint = stream.endpoint();
  ASSERT_EQ(endpoint.address(),
            boost::asio::ip::address::from_string("127.0.0.1"));
  ASSERT_EQ(endpoint.port(), 80);
}

TEST(DataStream, EmptyEndPointIsCorrectlyReadFromStream) {
  char data[] = {0x00};
  cs::DataStream stream(data, sizeof data);
  boost::asio::ip::udp::endpoint endpoint = stream.endpoint();
  ASSERT_EQ(endpoint.address(), boost::asio::ip::address());
  ASSERT_EQ(endpoint.port(), 0);
}

TEST(DataStream, EndPointWithOnlyIp4IsCorrectlyReadFromStream) {
  char data[] = {0x02, 0x7f, 0x00, 0x00, 0x01, 0x00};
  cs::DataStream stream(data, sizeof data);
  boost::asio::ip::udp::endpoint endpoint = stream.endpoint();
  ASSERT_EQ(endpoint.address(),
            boost::asio::ip::address::from_string("127.0.0.1"));
  ASSERT_EQ(endpoint.port(), 0);
}

TEST(DataStream, EndPointWithOnlyPortIsCorrectlyReadFromStream) {
  char data[] = {0x04, 0x7f, 0x00};
  cs::DataStream stream(data, sizeof data);
  boost::asio::ip::udp::endpoint endpoint = stream.endpoint();
  ASSERT_EQ(endpoint.address(), boost::asio::ip::address());
  ASSERT_EQ(endpoint.port(), 127);
}

TEST(DataStream, Int32ValueIsCorrectylyReadFromStream) {
  char data[] = {0x78, 0x56, 0x34, 0x12};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.streamField<int32_t>();
  ASSERT_EQ(value, 0x12345678);
}

TEST(DataStream, Int32ValueIsCorrectylyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  int32_t value = 0x12345678;
  stream.setStreamField<int32_t>(value);
  ASSERT_EQ(bytes, cs::Bytes({0x78, 0x56, 0x34, 0x12}));
}

TEST(DataStream, ByteArrayIsCorrectlyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  cs::ByteArray<8> array = {0, 1, 2, 3, 4, 5, 5, 145};
  stream.setByteArray(array);
  ASSERT_EQ(bytes, cs::Bytes({0, 1, 2, 3, 4, 5, 5, 145}));
}

TEST(DataStream, ByteArrayIsCorrectlyReadFromStream) {
  char data[] = {0x78, 0x56, 0x34, 0x12};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.byteArray<4>();
  ASSERT_EQ(value.size(), 4);
  ASSERT_EQ(value[0], 0x78);
  ASSERT_EQ(value[1], 0x56);
  ASSERT_EQ(value[2], 0x34);
  ASSERT_EQ(value[3], 0x12);
}

TEST(DataStream, MustGetZeroFilledByteArrayIfRequestedTooMany) {
  char data[] = {0x78, 0x56, 0x34, 0x12};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.byteArray<5>();
  ASSERT_EQ(value.size(), 5);
  ASSERT_EQ(value[0], 0);
  ASSERT_EQ(value[1], 0);
  ASSERT_EQ(value[2], 0);
  ASSERT_EQ(value[3], 0);
  ASSERT_EQ(value[4], 0);
}

TEST(DataStream, CorrectlySkipsRequestedNumberOfBytes) {
  char data[8] = "1234567";
  cs::DataStream stream(data, sizeof data);
  ASSERT_TRUE(stream.isAvailable(8));
  stream.skip<3>();
  ASSERT_TRUE(stream.isAvailable(5));
  stream.skip<4>();
  ASSERT_TRUE(stream.isAvailable(1));
  stream.skip<1>();
  ASSERT_FALSE(stream.isAvailable(1));
}

TEST(DateStream, TransactionHashIsCorrectlyReadFromStream) {
  unsigned char data[] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,
                          0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e,
                          0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,
                          0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.transactionsHash();
  ASSERT_EQ(value.toString(),
            "D41D8CD98F00B204E9800998ECF8427ED41D8CD98F00B204E9800998ECF8427E");
}

TEST(DataStream, TransactionsHashIsCorrectlyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  cs::TransactionsPacketHash hash = cs::TransactionsPacketHash::fromString(
      "d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e");
  stream.addTransactionsHash(hash);
  const cs::Bytes target_bytes(
      {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x1d,
       0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98,
       0xec, 0xf8, 0x42, 0x7e, 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00,
       0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e});
  ASSERT_EQ(bytes, target_bytes);
}

TEST(DataStream, VectorIsCorrectlyWritenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  cs::Bytes vector = {1, 2, 3, 4, 5};
  stream.addVector(vector);
  const cs::Bytes target_bytes({0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x01, 0x02, 0x03, 0x04, 0x05});
  ASSERT_EQ(bytes, target_bytes);
}

TEST(DateStream, VectorIsCorrectlyReadFromStream) {
  unsigned char data[] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.byteVector();
  ASSERT_EQ(value, cs::Bytes({1, 2, 3, 4, 5}));
}

TEST(DataStream, StdStringIsCorrectlyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  std::string string = "string string ascii string ";
  stream.addString(string);
  const cs::Bytes target_bytes(
      {0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x74, 0x72, 0x69,
       0x6e, 0x67, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x73,
       0x63, 0x69, 0x69, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20});
  ASSERT_EQ(bytes, target_bytes);
}

TEST(DataStream, StdStringIsCorrectlyReadFromStream) {
  unsigned char data[] = {0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20};
  cs::DataStream stream(data, sizeof data);
  auto value = stream.string();
  ASSERT_EQ(value, "string ");
}

const cs::HashVector kTestHashVector{
    0xEE,
    cs::ByteArray<HASH_LENGTH>{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
                               0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
                               0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
                               0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
    cs::ByteArray<SIGNATURE_LENGTH>{
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
        0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
        0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}};

const cs::Bytes kEncodedTestHashVector = {
    0xee, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
    0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
    0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
    0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
    0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0};

template <class Container>
void Output(const Container& container) {
  std::cout << "bytes = ";
  for (const auto& i : container) {
    std::cout << "0x" << std::hex << std::setw(2) << std::setfill('0') << int(i)
              << ", ";
  }
  std::cout << std::endl;
}

TEST(DataStream, HashVectorIsCorrectlyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  stream.addHashVector(kTestHashVector);
  ASSERT_EQ(bytes, kEncodedTestHashVector);
}

bool operator==(const cs::HashVector& left, const cs::HashVector& right) {
  return left.sender == right.sender and left.hash == right.hash and
         left.signature == right.signature;
}

TEST(DataStream, HashVectorIsCorrectlyReadFromStream) {
  cs::DataStream stream(kEncodedTestHashVector.data(),
                        kEncodedTestHashVector.size());
  auto value = stream.hashVector();
  ASSERT_TRUE(value == kTestHashVector);
}

bool operator==(const cs::HashMatrix& left, const cs::HashMatrix& right) {
  bool hash_vectors_are_identical = true;
  for (auto i = 0u; i < cs::hashVectorCount; ++i) {
    hash_vectors_are_identical &= left.hashVector[i] == right.hashVector[i];
  }
  return left.sender == right.sender and hash_vectors_are_identical and
         left.signature == right.signature;
}

const cs::HashMatrix kTestHashMatrix{
    0xEE,
    {{0x01,
      cs::ByteArray<HASH_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
      cs::ByteArray<SIGNATURE_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
          0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
          0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
          0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}},
     {0x02,
      cs::ByteArray<HASH_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
      cs::ByteArray<SIGNATURE_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
          0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
          0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
          0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}},
     {0x03,
      cs::ByteArray<HASH_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
      cs::ByteArray<SIGNATURE_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
          0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
          0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
          0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}},
     {0x04,
      cs::ByteArray<HASH_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
      cs::ByteArray<SIGNATURE_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
          0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
          0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
          0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}},
     {0x05,
      cs::ByteArray<HASH_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0},
      cs::ByteArray<SIGNATURE_LENGTH>{
          0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
          0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
          0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
          0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
          0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
          0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}}

    },
    cs::ByteArray<SIGNATURE_LENGTH>{
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
        0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
        0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}};

const cs::Bytes kEncodedTestHashMatrix = {
    0xee, 0x01, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x02, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
    0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
    0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
    0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
    0xbc, 0xde, 0xf0, 0x03, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
    0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
    0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
    0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
    0x9a, 0xbc, 0xde, 0xf0, 0x04, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
    0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
    0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
    0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
    0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
    0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
    0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
    0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
    0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x05, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
    0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0};

TEST(DataStream, HashMatrixIsCorrectlyWrittenToStream) {
  cs::Bytes bytes;
  cs::DataStream stream(bytes);
  stream.addHashMatrix(kTestHashMatrix);
  ASSERT_EQ(bytes, kEncodedTestHashMatrix);
}

TEST(DataStream, HashMatrixIsCorrectlyReadFromStream) {
  cs::DataStream stream(kEncodedTestHashMatrix.data(),
                        kEncodedTestHashMatrix.size());
  auto value = stream.hashMatrix();
  ASSERT_TRUE(value == kTestHashMatrix);
}

TEST(DataStream, PeekCorrectValueFromStream) {
  char data[] = {0x78, 0x56, 0x34, 0x12};
  cs::DataStream stream(data, sizeof data);
  int32_t written_value = 0x12345678;
  decltype(auto) read_value = stream.peek<int32_t>();
  ASSERT_EQ(written_value, read_value);
}
